#!/bin/bash

source_check_bad_code_sections() {
    # checks for ``` followd by a blank
    local name="$1"
    local book_source="$2"
    local book_ppdir="$3"
    local book_out="$4"

    echo "##### 1 checking for bad code sections in ${name}"
    if grep -qR  "^${TRIPPLETICS} *.* " "${book_source}"; then
        err "tripple tics with blanks afterwards found: "
        grep -R  "^${TRIPPLETICS} *.* " "${book_source}"
        exit 1
    fi
}

source_check_bad_headings() {
    # TODO description
    local name="$1"
    local book_source="$2"
    local book_ppdir="$3"
    local book_out="$4"

    echo "##### 2 checking for headers that won't proper display on github in ${name}"
    if grep -qRI  '^##*[a-zA-Z]' "${book_source}"; then
        err "Headlines broken on github found: "
        grep -RI  '^##*[a-zA-Z]' "${source}"
        exit 1
    fi
}

pp_check_summary() {
    # check if all md files are included in the SUMMARY.md in the books source
    local name="$1"
    local book_source="$2"
    local book_ppdir="$3"
    local book_out="$4"

    # in pp
    find "$book_ppdir" -name '*.md' | \
        sed -e "s;$book_ppdir/;;" | \
        grep -vf SummaryBlacklist.txt | \
        grep -v gitbook-plugin | \
        grep -v node_modules/ | \
        sort > /tmp/is_md.txt || ferr "is_md.txt generation failed"

    # in source
    # remove comments
    # remove everything before and after the braces
    grep -v '^ *# '< "${book_source}/SUMMARY.md" | \
        grep '(' | sed -e "s;.*(;;" -e "s;).*;;" | \
        sort  > /tmp/is_summary.txt || ferr "is_summary generation failed"

    #compare both files
    if test "$(comm -3 /tmp/is_md.txt /tmp/is_summary.txt|wc -l)" -ne 0; then
        err "not all files of ${name} are mapped to the summary!"
        err "files found       |    files in summary"
        comm -3 /tmp/is_md.txt /tmp/is_summary.txt
        exit 1
    fi
}

pp_check_leftover_docublocks() {
    local name="$1"
    local book_source="$2"
    local book_ppdir="$3"
    local book_out="$4"

    #in ppdir
    echo "##### 4 checking for left over docublocks in ${name}"
    ERRORS="$(grep -rl "startDocuBlock" --include "*.md" "$book_ppdir")"
    (( $? > 1)) && ferr "Failed running chek for leftover DocuBlocks"
    if [[ -n "${ERRORS}" ]]; then
        echo "startDocuBlock markers still found in generated output files:"
        echo "${ERRORS}" | sed -e "s/^/- /g"
        exit 1
    fi
}

pp_check_restheader_leftovers() {
    # TODO description
    local name="$1"
    local book_source="$2"
    local book_ppdir="$3"
    local book_out="$4"

    ## original script:
    ## what is this supposed to do?
    ## - bad use of prune!
    ## - how can the expression match without `-E`
    # ERRORS=$(find "ppbooks/${NAME}" -not \( -path "ppbooks/Drivers/SpringData/*" -prune \) -name "*.md" -exec grep -- '^@[A-Z]*' {} \; -print) || failed "check for restheader leftovers"

    #in ppdir
    #TODO FIXME why is the spring data driver excluded??
    # what is that for "^@[A-Z]*"
    echo "##### 5 checking for restheader leftovers in ${name}"
    ERRORS="$(find "$book_ppdir"  -path "*/Drivers/SpringData/*" -prune  -o -name "*.md" -exec bash -c 'grep -E -q -- "^@[A-Z]*" "$1" && echo $1' -- '{}' \; )" || failed "check for restheader leftovers"
    if [[ -n "${ERRORS}" ]]; then
        echo ""
        echo "found these unconverted Swagger Restapi tags: "
        echo "${ERRORS}"
        echo ""
        exit 1
    fi
}

function ppbook-check-two-links()
{
    # TODO description
    local name="$1"
    local book_source="$2"
    local book_ppdir="$3"
    local book_out="$4"
    NAME="$1"
    echo "##### 6 checking for two links in a single line in ${NAME}"
    ERRORS=$(find "ppbooks/${NAME}" \
                  -path "ppbooks/${NAME}/node_modules" \
                  -prune -o \
                  -name '*.md' \
                  -print | while IFS= read -r ppfile; do
                 ERR=$(grep -e '](.*](' "${ppfile}" | grep -v '|'||true)
                 if test -n "${ERR}"; then
                     printf "\n${ppfile}: \n ${ERR}"
                 fi
             done
          )
    if test "$(printf "${ERRORS}" | wc -l)" -gt 0; then
        echo "";
        echo "found these files with two links in one line: "
        echo "${ERRORS}"
        echo "";
        exit 1;
    fi
}

function ppbook-check-directory-link()
{
    # TODO description
    local name="$1"
    local book_source="$2"
    local book_ppdir="$3"
    local book_out="$4"
    NAME="$1"
    echo "##### 7 checking for invalid md links in ${NAME}"
    ERRORS=$(grep -r -E '\[.*\]\(.*\)' "ppbooks/${NAME}" | \
                    grep '\.md:' | \
                    grep -v html | \
                    grep -v http://| \
                    grep -v https:// | \
                    grep -v header.css | \
                    grep -v node_modules | \
                    grep -v node_modules | \
                    grep -v '\.md')
    nERRORS=$(echo -n "${ERRORS}" | wc -l)
    if test "$nERRORS" -gt 0; then
        echo ""
        echo "Found director links! use ../<directory>/README.md instead!"
        echo "${ERRORS}"
        echo ""
        exit 1
    fi
}

function book-check-images-referenced()
{
    # TODO description
    local name="$1"
    local book_source="$2"
    local book_ppdir="$3"
    local book_out="$4"
    NAME="$1"
    echo "##### 8 checking for unused image files ${NAME}"
    ERRORS=$(find "${NAME}" -name '*.png' | while IFS= read -r image; do
            baseimage=$(basename "$image")
            if ! grep -Rq "${baseimage}" "${NAME}"; then
                printf "\n${image}"
            fi
        done
    )
    if test "$(printf "${ERRORS}" | wc -l)" -gt 0; then
        echo "";
        echo "the following images are not referenced by any page: "
        echo "${ERRORS}"
        echo "";
        exit 1;
    fi
}

# checks we do not reach yet

function ppbook-check-html-link()
{
    # TODO description
    set -o pipefail
    NAME="$1"
    MSG="$2"
    echo "##### zzz checking for invalid HTML links in ${NAME}"
    echo "${ALLBOOKS}" | tr " " "\n" | sed -e 's;^;/;' -e 's;$;/;' > /tmp/books.regex

    grep -r -E '\[.*\]\(.*\)' "ppbooks/${NAME}"| \
        grep '\.md:'| grep 'html'| \
        grep -v 'http://' | \
        grep -v 'https://' | \
        grep -v 'header.css' | \
        grep -v -f /tmp/books.regex > /tmp/relative_html_links.txt

    if test "$(wc -l < /tmp/relative_html_links.txt)" -gt 0; then
        echo ""
        echo "Found links to .html files inside of the document! use <foo>.md instead!"
        echo "${MSG}"
        cat  /tmp/relative_html_links.txt
        echo ""
        exit 1
    fi
}

book_check_post_build_markdown_leftovers() {
    # TODO description
    local name="$1"
    local book_out="$2"
    echo "##### checking for remaining markdown snippets in the HTML output of ${name} in $book_out"

    ERRORS=$(find "$book_out" -name '*.html' -exec grep -- '^##' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found these unconverted markdown titles"
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep -- '&amp;gt;' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found these double converted > signs"
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '"[a-zA-Z/\.]*\.md\"[ />]' {} \; -print | grep -v data-filepath)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found dangling markdown links; see the list above "
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '"[a-zA-Z/\.]*\.md#' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found dangling markdown links: "
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep "${TRIPPLETICS}" {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found dangling markdown code sections: "
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '\]<a href' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found unconverted markdown links: "
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '\[.*\](.*[\.html|\.md|http|#.*])' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found unconverted markdown links: "
    fi
}


function check-dangling-anchors()
{
    # TODO description
    rm -rf /tmp/tags/
    echo "##### checking for dangling anchors"
    find books/ -name '*.html' | while IFS= read -r htmlf; do
        fn=$(basename "${htmlf}")
        dir=$(sed "s;/$fn;;" <<< "$htmlf")
        mkdir -p "/tmp/tags/${dir}"
        grep '<h. ' < "${htmlf}" | \
            sed -e 's;.*id=";;' -e 's;".*;;' > "/tmp/tags/${dir}/${fn}"
    done

    fail=0
    rm -f /tmp/failduplicatetags.txt
    find /tmp/tags -type f | while IFS= read -r htmlf; do
        sort "${htmlf}" |grep -v ^$ > /tmp/sorted.txt
        sort -u "${htmlf}" |grep -v ^$ > /tmp/sortedunique.txt
        if test "$(comm -3 /tmp/sorted.txt /tmp/sortedunique.txt|wc -l)" -ne 0; then
            echo "in ${htmlf}: "
            comm -3 /tmp/sorted.txt /tmp/sortedunique.txt
            touch /tmp/failduplicatetags.txt
        fi
    done

    rm -f /tmp/sorted.txt /tmp/sortedunique.txt
    if test -f /tmp/failduplicatetags.txt; then
        echo "duplicate anchors detected - see above"
        rm -f /tmp/failduplicatetags.txt
        exit 1
    fi

    rm -f /tmp/anchorlist.txt

    echo "##### fetching anchors from generated http files"
    for file in $(find books -name \*.html); do
        # - strip of the menu
        # - then the page tail.
        # - remove links to external pages
        cat $file | \
            sed -r -n -e '/normal markdown-section/,${p}'| \
            sed -r -n -e '/.*id="page-footer".*/q;p' | \
            grep '<a href="' | \
            grep -v 'target="_blank"' | \
            sed -e 's;.*href=";;' -e 's;".*;;' > /tmp/thisdoc.txt
        # Links with anchors:
        cat /tmp/thisdoc.txt |grep '#' | sed "s;\(.*\)#\(.*\);${file},\1,\2;" >> /tmp/anchorlist.txt
        # links without anchors:
        cat /tmp/thisdoc.txt |grep -v '#' | sed "s;\(.*\);${file},\1,;" >> /tmp/anchorlist.txt

    done

    echo "##### cross checking anchors"
    NO=0
    echo "${NO}" > /tmp/anchorlistcount.txt
    # shellcheck disable=SC2002
    cat /tmp/anchorlist.txt | while IFS= read -r i; do
        ANCHOR=$(echo "$i" | cut '-d,' -f 3)
        FN=$(echo "$i" | cut '-d,' -f 2)
        SFN=$(echo "$i" | cut '-d,' -f 1)

        if test -z "$FN"; then
            FN="$SFN"
        else
            SFNP=$(sed 's;/[a-zA-Z0-9.-]*.html;;' <<< "$SFN")
            FN="${SFNP}/${FN}"
        fi
        if test -d "$FN"; then
            FN="${FN}index.html"
        fi
        if test ! -f "/tmp/tags/${FN}"; then
            echo ""
            echo "File referenced by ${i} doesn't exist."
            NO=$((NO + 1))
            echo ""
        else
            if test -n "$ANCHOR"; then
                if grep -q "^$ANCHOR$" "/tmp/tags/${FN}"; then
                    true
                else
                    echo ""
                    echo "Anchor not found in $i"
                    NO=$((NO + 1))
                    echo "available anchors in that file:"
                    cat "/tmp/tags/${FN}" |sort
                    echo ""
                fi
            fi
        fi
        echo "${NO}" > /tmp/anchorlistcount.txt
    done
    NO="$(cat /tmp/anchorlistcount.txt)"
    if test "${NO}" -gt 0; then
        echo ""
        echo "${NO} Dangling anchors found!"
        echo ""
        echo "${1}"
        echo ""
        exit 1
    fi
    rm -rf /tmp/anchorlist.txt /tmp/tags
}

#************************************************************
# Check docublocks - checks whether docublock are
#  - files in intermediate output directories and temporary
#    files are excludes (with # in their names)
#  - unique in the source
#  - all docublocks are used somewhere in the documentation
#
function check-docublocks()
{
    # TODO description
    # set -o pipefail
    # #set -e
    # pwd
    # ls -lisahd ./ppbooks/Summary.md
    # ls -lisah ./ppbooks/*md
    # debug "not found 1"

    # grep -R '@startDocuBlock' \
    #      --include "*.h" \
    #      --include "*.cpp" \
    #      --include "*.js" \
    #      --include "*.md" \
    #      . \
    #      1>/dev/null || ferr "grep failed"




    grep -R '@startDocuBlock' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v '@startDocuBlockInline' |\
        grep -v stash |\
        grep -v ppbook |\
        grep -v allComments.txt |\
        grep -v Makefile |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             > /tmp/rawindoc.txt
    debug "not found 1 - end"

    debug "not found 2"
    grep -R '@startDocuBlockInline' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v ppbook |\
        grep -v stash |\
        grep -v allComments.txt |\
        grep -v Makefile |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             >> /tmp/rawindoc.txt
    debug "not found 2 - end"
    sed  -e "s;\r$;;" -e "s;.*ck ;;" -e "s;.*ne ;;" < /tmp/rawindoc.txt |sort -u > /tmp/indoc.txt

    debug "not found 3"
    grep -R '^@startDocuBlock' ../DocuBlocks --include "*.md" |grep -v aardvark > /tmp/rawinprog.txt
    # searching the Inline docublocks needs some more blacklisting:
    grep -R '@startDocuBlockInline' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v ppbook |\
        grep -v stash |\
        grep -v allComments.txt |\
        grep -v build.sh |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             >> /tmp/rawinprog.txt
    debug "not found 3 - end"

    # These files are converted to docublocks on the fly and only live in memory.
    for file in ../Examples/*.json ; do
        echo "$file" |sed -e "s;.*/;Generated: @startDocuBlock program_options_;" -e "s;.json;;" >> /tmp/rawinprog.txt
    done
    echo "Generated: startDocuBlockInline errorCodes">> /tmp/rawinprog.txt

    sed -e "s;\r$;;" -e "s;.*ck ;;" -e "s;.*ne ;;" < /tmp/rawinprog.txt  |sort > /tmp/inprog_raw.txt
    sort -u < /tmp/inprog_raw.txt > /tmp/inprog.txt
    if test "$(wc -l < /tmp/inprog.txt)" -ne "$(wc -l < /tmp/inprog_raw.txt)"; then
        echo ""
        echo "Duplicate entry found in the source trees:"
        comm -3 /tmp/inprog_raw.txt /tmp/inprog.txt
        echo ""
        echo "${1}"
        echo ""
        exit 1
    fi

    if test "$(comm -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -ne 0; then
        echo ""
        echo "Not all blocks were found on both sides:"
        echo "Documentation      |     Programcode:"
        comm -3 /tmp/indoc.txt /tmp/inprog.txt
        if test "$(comm -2 -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -gt 0; then
            echo "Documentation: "
            for grepit in $(comm -2 -3 /tmp/indoc.txt /tmp/inprog.txt); do
                grep "$grepit" /tmp/rawindoc.txt
            done
        fi
        if test "$(comm -1 -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -gt 0; then
            echo "Program code:"
            for grepit in $(comm -1 -3 /tmp/indoc.txt /tmp/inprog.txt); do
                grep "$grepit" /tmp/rawinprog.txt | sed "s;/// @startDocuBlock;\t\t;"
            done
        fi
        echo ""
        echo "${1}"
        echo ""
        exit 1
    fi
}

show_config(){
    echo "  build lib sourced"
    echo "  passed arguments: '$@'"
    echo
    section "ArangoDB documentation build configuration"
    echo "directories:"
    echo "  script dir:  $script_dir"
    echo "  work:         $ARANGO_WORK"
    echo "  source:       $ARANGO_SOURCE"
    echo "  books:        $ARANGO_SOURCE_DOC_BOOKS"
    echo "  build:        $ARANGO_BUILD_DOC"
    echo "  build ppdir:  $ARANGO_BUILD_DOC_PPDIR"
    echo "  build books:  $ARANGO_BUILD_DOC_BOOKS"
    echo
    echo "versions:"
    echo "  newVersionNumber: $newVersionNumber - from : arangodb/VERSION"
    echo "  VERSION: $VERSION"
    echo "  BROWSEABLE_VERSIONS: $BROWSEABLE_VERSIONS"
    echo "  INSTALLED_GITBOOK_VERSION: $INSTALLED_GITBOOK_VERSION"
    echo "  RELEASE_DIRECTORY: $RELEASE_DIRECTORY"
    echo
    echo "google:"
    echo "  GCHANGE_FREQ: $GCHANGE_FREQ"
    echo "  GPRIORITY: $GPRIORITY"
    echo "  ALL_GSEARCH_ID:"
    for id in  "${ALL_GSEARCH_ID[@]}"; do
        echo "    $id"
    done
    echo

    #sleep 3
}


#### Snippets to be replaced

## build non html books
## function build-book-dist()
## {
##     NAME="$1"
##     export DISPLAY="$2"
##     cd "ppbooks/${NAME}"
##     for ext in ${OTHER_MIME}; do
##         OUTPUT="${OUTPUT_DIR}/ArangoDB_${NAME}_${newVersionNumber}.${ext}"
##         if gitbook "${GITBOOK_ARGS[@]}" "${ext}" ./ "${OUTPUT}"; then
##             echo "success building ${OUTPUT}"
##         else
##             exit 1
##         fi
##     done
## }
