#!/bin/bash

grep_ignore_empty(){
    grep "$@"
    local rv=$?

    # grep exit status is 1 if nothing is matched
    (( rv == 1 )) &&  { false && debug "echo no match found via 'grep $@'" >&2; return 0; }
    return $rv
}
# make it available for sub-shells
export -f grep_ignore_empty

source_check_bad_code_sections() {
    # checks for ``` followd by a blank
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    echo "##### 1 checking for bad code sections in ${book_name}"
    if grep -qR  "^${TRIPPLETICS} *.* " "${book_src}"; then
        err "tripple tics with blanks afterwards found: "
        grep -R  "^${TRIPPLETICS} *.* " "${book_src}"
        exit 1
    fi
}

source_check_bad_headings() {
    # TODO description
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    echo "##### 2 checking for headers that won't proper display on github in ${book_name}"
    if grep -qRI  '^##*[a-zA-Z]' "${book_src}"; then
        err "Headlines broken on github found: "
        grep -RI  '^##*[a-zA-Z]' "${source}"
        exit 1
    fi
}

pp_check_summary() {
    # check if all md files are included in the SUMMARY.md in the books source
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    # in pp
    find "$book_pre" -name '*.md' | \
        sed -e "s;$book_pre/;;" | \
        grep -vf SummaryBlacklist.txt | \
        grep -v gitbook-plugin | \
        grep -v node_modules/ | \
        sort > /tmp/is_md.txt || ferr "is_md.txt generation failed"

    # in source
    # remove comments
    # remove everything before and after the braces
    grep -v '^ *# '< "${book_src}/SUMMARY.md" | \
        grep '(' | sed -e "s;.*(;;" -e "s;).*;;" | \
        sort  > /tmp/is_summary.txt || ferr "is_summary generation failed"

    #compare both files
    if test "$(comm -3 /tmp/is_md.txt /tmp/is_summary.txt|wc -l)" -ne 0; then
        err "not all files of ${book_name} are mapped to the summary!"
        err "files found       |    files in summary"
        comm -3 /tmp/is_md.txt /tmp/is_summary.txt
        exit 1
    fi
}

pp_check_leftover_docublocks() {
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    #in ppdir
    echo "##### 4 checking for left over docublocks in ${book_name}"
    ERRORS="$(grep -rl "startDocuBlock" --include "*.md" "$book_pre")"
    (( $? > 1 )) && ferr "Failed running chek for leftover DocuBlocks"
    if [[ -n "${ERRORS}" ]]; then
        echo "startDocuBlock markers still found in generated output files:"
        echo "${ERRORS}" | sed -e "s/^/- /g"
        exit 1
    fi
}

pp_check_restheader_leftovers() {
    # TODO description
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    ## original script:
    ## what is this supposed to do?
    ## - bad use of prune!
    ## - how can the expression match without `-E`
    # ERRORS=$(find "ppbooks/${book_name}" -not \( -path "ppbooks/Drivers/SpringData/*" -prune \) -name "*.md" -exec grep -- '^@[A-Z]*' {} \; -print) || failed "check for restheader leftovers"

    #in ppdir
    #TODO FIXME why is the spring data driver excluded??
    # what is that for "^@[A-Z]*"
    echo "##### 5 checking for restheader leftovers in ${book_name}"
    ERRORS="$(find "$book_pre"  -path "*/Drivers/SpringData/*" -prune  -o -name "*.md" -exec bash -c 'grep -E -q -- "^@[A-Z]*" "$1" && echo $1' -- '{}' \; )" || failed "check for restheader leftovers"
    if [[ -n "${ERRORS}" ]]; then
        echo "found these unconverted Swagger Restapi tags: "
        echo "${ERRORS}"
        exit 1
    fi
}

pp_check_two_links() {
    # TODO description
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    #in ppdir
    local ERRORS=()
    echo "##### 6 checking for two links in a single line in ${book_name}"
    while IFS= read -r ppfile; do
        local search=$(grep -e '](.*](' "${ppfile}")
        (( $? > 1 )) && ferr "fail in check two links"
        local ERR="$(echo "$search" | grep -v '|' )"
        if [[ -n "${ERR}" ]]; then
            ERRORS+=( "\n${ppfile}: \n ${ERR}" )
        fi
    done < <(find "$book_pre" \
                  -path "$book_pre/node_modules*" \
                  -prune -o \
                  -name '*.md' \
                  -print
            ) || ferr "failed checking for two links"

    if [[ "${ERRORS[@]}" ]]; then
        echo "found these files with two links in one line: "
        echo "${ERRORS[@]}"
        exit 1;
    fi
}

function pp_check_directory_link()
{
    # TODO description
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"


    #in ppdir
    echo "##### 7 checking for invalid md links in ${book_name}"
    local ERRORS=$( grep -r -E '\[.*\]\(.*\)' "$book_pre" | \
                    grep '\.md:' | \
                    grep -v html | \
                    grep -v http://| \
                    grep -v https:// | \
                    grep -v header.css | \
                    grep -v node_modules | \
                    grep -v node_modules | \
                    grep -v '\.md') || ferr "failed checking for invalid links"


    if [[ -n "$ERRORS" ]]; then
        echo "Found directory links! use ../<directory>/README.md instead!"
        echo "${ERRORS}"
        exit 1
    fi
}

function src_check_images_referenced()
{
    # TODO description
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    echo "##### 8 checking for unused image files ${book_name}"
    local found=false
    while IFS= read -r image; do
        baseimage=$(basename "$image")
        if ! grep -Rq "${baseimage}" "${book_name}"; then
            ! $found && { echo "the following images are not referenced by any page: " ; found=true; }
            printf "\n${image}"
        fi
    done < <(find "${book_name}" -name '*.png')
    $found && exit 1;
    return 0
}

# checks we do not reach yet

pp_check_html_link() {
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    # TODO description

    set -o pipefail
    book_name="$1"
    msg="$2"
    echo "##### checking for invalid HTML links in ${book_name}"
    echo "${ALLBOOKS}" | tr " " "\n" | sed -e 's;^;/;' -e 's;$;/;' > /tmp/books.regex

    grep -r -E '\[.*\]\(.*\)' "$book_pre"| \
        grep '\.md:'| grep 'html'| \
        grep -v 'http://' | \
        grep -v 'https://' | \
        grep -v 'header.css' | \
        grep -v -f /tmp/books.regex > /tmp/relative_html_links.txt

        #no lines matched
        (( $? == 1 )) && return 0

    if [[ "$(wc -l < /tmp/relative_html_links.txt)" -gt 0 ]]; then
        echo "Found links to .html files inside of the document! use <foo>.md instead!"
        cat  /tmp/relative_html_links.txt
        exit 1
    fi
}

out_markdown_leftovers() {
    # TODO description
    local book_name="$1"
    local book_src="$2"
    local book_pre="$3"
    local book_out="$4"

    local ERRORS

    echo "##### checking for remaining markdown snippets in the HTML output of ${book_name} in $book_out"

    ERRORS=$(find "$book_out" -name '*.html' -exec grep -- '^##' {} \; -print) || ferr "markdown leftovers 1"
    if [[ -n "${ERRORS}" ]]; then
        err "found these unconverted markdown titles"
        echo "${ERRORS}"
        exit 1
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep -- '&amp;gt;' {} \; -print) || ferr "markdown leftovers 2"
    if [[ -n "${ERRORS}" ]]; then
        err "found these double converted > signs"
        echo "${ERRORS}"
        exit 1
    fi

    local ERRORS=()
    while IFS= read -r line; do
        grep -E '"[a-zA-Z/\.]*\.md\"[ />]' "$line" | grep -v data-filepath;
        local rv=$?
        (( rv == 0 )) && ERRORS+=( "$line" )
        (( rv == 2 )) && ferr "markdown leftovers 3"
    done < <(find "$book_out" -name '*.html')

    if [[ -n "${ERRORS[@]}" ]]; then
        err "found dangling markdown links"
        echo "${ERRORS[@]}"
        exit 1

    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '"[a-zA-Z/\.]*\.md#' {} \; -print) || ferr "markdown leftovers 4"
    if [[ -n "${ERRORS}" ]]; then
        err "found dangling markdown links: "
        echo "${ERRORS}"
        exit 1
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep "${TRIPPLETICS}" {} \; -print) || ferr "markdown leftovers 5"
    if [[ -n "${ERRORS}" ]]; then
        err "found dangling markdown code sections: "
        echo "${ERRORS}"
        exit 1
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '\]<a href' {} \; -print) || ferr "markdown leftovers 6"
    if [[ -n "${ERRORS}" ]]; then
        err "found unconverted markdown links: "
        echo "${ERRORS}"
        exit 1
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '\[.*\](.*[\.html|\.md|http|#.*])' {} \; -print) || ferr "markdown leftovers 7"
    if [[ -n "${ERRORS}" ]]; then
        err "found unconverted markdown links: "
        echo "${ERRORS}"
        exit 1
    fi
}


function cross_check_dangling_anchors()
{
    ##TODO FIXME
    # TODO description
    rm -rf /tmp/tags/
    echo "##### checking for dangling anchors"
    find "$ARANGO_BUILD_DOC_OUT" -name '*.html' | while IFS= read -r htmlf; do
        fn=$(basename "${htmlf}")
        echo $fn
        dir=$(sed "s;/$fn;;" <<< "$htmlf")
        mkdir -p "/tmp/tags/${dir}"
        grep '<h. ' < "${htmlf}" | \
            sed -e 's;.*id=";;' -e 's;".*;;' > "/tmp/tags/${dir}/${fn}"
    done

    debug "one"

    fail=0
    rm -f /tmp/failduplicatetags.txt
    find /tmp/tags -type f | while IFS= read -r htmlf; do
        sort "${htmlf}" |grep -v ^$ > /tmp/sorted.txt
        sort -u "${htmlf}" |grep -v ^$ > /tmp/sortedunique.txt
        if test "$(comm -3 /tmp/sorted.txt /tmp/sortedunique.txt|wc -l)" -ne 0; then
            echo "in ${htmlf}: "
            comm -3 /tmp/sorted.txt /tmp/sortedunique.txt
            touch /tmp/failduplicatetags.txt
        fi
    done
    debug "two"

    rm -f /tmp/sorted.txt /tmp/sortedunique.txt
    if test -f /tmp/failduplicatetags.txt; then
        echo "duplicate anchors detected - see above"
        rm -f /tmp/failduplicatetags.txt
        exit 1
    fi

    rm -f /tmp/anchorlist.txt
    debug "three"

    echo "##### fetching anchors from generated http files"
    for file in $(find "$ARANGO_BUILD_DOC_OUT" -name \*.html); do
        # - strip of the menu
        # - then the page tail.
        # - remove links to external pages
        cat $file | \
            sed -r -n -e '/normal markdown-section/,${p}'| \
            sed -r -n -e '/.*id="page-footer".*/q;p' | \
            grep_ignore_empty '<a href="' | \
            grep_ignore_empty -v 'target="_blank"' | \
            sed -e 's;.*href=";;' -e 's;".*;;' > /tmp/thisdoc.txt || { ls -lisah "$file"; ferr "fail cat $file"; }

        if [[ -f /tmp/thisdoc.txt ]]; then
            # Links with anchors:
            cat /tmp/thisdoc.txt | grep_ignore_empty '#' | sed "s;\(.*\)#\(.*\);${file},\1,\2;" >> /tmp/anchorlist.txt || ferr "fail 1 cat thisdoc.txt for: $file"
            # links without anchors:
            cat /tmp/thisdoc.txt | grep_ignore_empty -v '#' | sed "s;\(.*\);${file},\1,;" >> /tmp/anchorlist.txt || ferr "fail 2 cat thisdoc.txt for file: $file"
        fi
    done
    ## why do we create anchorlist above, when we delete it in the next lines?
    debug "four"

    echo "##### cross checking anchors"
    NO=0
    echo "${NO}" > /tmp/anchorlistcount.txt
    # shellcheck disable=SC2002
    cat /tmp/anchorlist.txt | while IFS= read -r i; do
        ANCHOR=$(echo "$i" | cut '-d,' -f 3)
        FN=$(echo "$i" | cut '-d,' -f 2)
        SFN=$(echo "$i" | cut '-d,' -f 1)

        if test -z "$FN"; then
            FN="$SFN"
        else
            SFNP=$(sed 's;/[a-zA-Z0-9.-]*.html;;' <<< "$SFN")
            FN="${SFNP}/${FN}"
        fi
        if test -d "$FN"; then
            FN="${FN}index.html"
        fi
        if test ! -f "/tmp/tags/${FN}"; then
            echo ""
            echo "File referenced by ${i} doesn't exist."
            NO=$((NO + 1))
            echo ""
        else
            if test -n "$ANCHOR"; then
                if grep -q "^$ANCHOR$" "/tmp/tags/${FN}"; then
                    true
                else
                    echo ""
                    echo "Anchor not found in $i"
                    NO=$((NO + 1))
                    echo "available anchors in that file:"
                    cat "/tmp/tags/${FN}" |sort
                    echo ""
                fi
            fi
        fi
        echo "${NO}" > /tmp/anchorlistcount.txt
    done
    NO="$(cat /tmp/anchorlistcount.txt)"
    if test "${NO}" -gt 0; then
        echo "${NO} Dangling anchors found!"
        exit 1
    fi
    rm -rf /tmp/anchorlist.txt /tmp/tags
    debug "five"
}

#************************************************************
# Check docublocks - checks whether docublock are
#  - files in intermediate output directories and temporary
#    files are excludes (with # in their names)
#  - unique in the source
#  - all docublocks are used somewhere in the documentation
#
function cross_check_docublocks() {
    #TODO - FIXME

    cd "$ARANGO_BUILD_DOC_OUT"
    pwd

    grep -R '@startDocuBlock' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v '@startDocuBlockInline' |\
        grep -v stash |\
        grep -v ppbook |\
        grep -v allComments.txt |\
        grep -v Makefile |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             > /tmp/rawindoc.txt || err "failed search for startDocuBlock - with $?"
    ###
    echo "in rawdoc"
    cat /tmp/rawindoc.txt | wc -l



    grep -R '@startDocuBlockInline' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v ppbook |\
        grep -v stash |\
        grep -v allComments.txt |\
        grep -v Makefile |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             >> /tmp/rawindoc.txt || err "failed to search for startDocuBlockInline - with $?"
    sed  -e "s;\r$;;" -e "s;.*ck ;;" -e "s;.*ne ;;" < /tmp/rawindoc.txt | sort -u > /tmp/indoc.txt
    ###
    echo "in doc"
    cat /tmp/rawindoc.txt | wc -l



    grep -R '^@startDocuBlock' "$ARANGO_SOURCE_DOC/DocuBlocks" --include "*.md" |grep -v aardvark > /tmp/rawinprog.txt
    # searching the Inline docublocks needs some more blacklisting:
    grep -R '@startDocuBlockInline' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v ppbook |\
        grep -v stash |\
        grep -v allComments.txt |\
        grep -v build.sh |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             >> /tmp/rawinprog.txt || err "failed to search for startDocuBlock in source - with $?"
    ###
    echo "in prog"
    cat /tmp/rawinprog.txt | wc -l

    # These files are converted to docublocks on the fly and only live in memory.
    for file in "$ARANGO_SOURCE_DOC/Examples/"*.json ; do
        echo "$file" |sed -e "s;.*/;Generated: @startDocuBlock program_options_;" -e "s;.json;;" >> /tmp/rawinprog.txt
    done
    echo "Generated: startDocuBlockInline errorCodes">> /tmp/rawinprog.txt

    sed -e "s;\r$;;" -e "s;.*ck ;;" -e "s;.*ne ;;" < /tmp/rawinprog.txt  |sort > /tmp/inprog_raw.txt
    sort -u < /tmp/inprog_raw.txt > /tmp/inprog.txt
    if test "$(wc -l < /tmp/inprog.txt)" -ne "$(wc -l < /tmp/inprog_raw.txt)"; then
        echo ""
        echo "Duplicate entry found in the source trees:"
        comm -3 /tmp/inprog_raw.txt /tmp/inprog.txt
        ferr "Duplicate entry found in the source trees:"
    fi

    if test "$(comm -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -ne 0; then
        echo ""
        echo "Not all blocks were found on both sides:"
        echo "Documentation      |     Programcode:"
        comm -3 /tmp/indoc.txt /tmp/inprog.txt
        if test "$(comm -2 -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -gt 0; then
            echo "Documentation: "
            for grepit in $(comm -2 -3 /tmp/indoc.txt /tmp/inprog.txt); do
                grep "$grepit" /tmp/rawindoc.txt
            done
        fi
        if test "$(comm -1 -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -gt 0; then
            echo "Program code:"
            for grepit in $(comm -1 -3 /tmp/indoc.txt /tmp/inprog.txt); do
                grep "$grepit" /tmp/rawinprog.txt | sed "s;/// @startDocuBlock;\t\t;"
            done
        fi
        ferr "Not all blocks were found on both sides:"
    fi
}

show_config(){
    echo "  build lib sourced"
    echo "  passed arguments: '$@'"
    echo
    section "ArangoDB documentation build configuration"
    echo "directories:"
    echo "  script dir:  $script_dir"
    echo "  work:         $ARANGO_WORK"
    echo "  source:       $ARANGO_SOURCE"
    echo "  books:        $ARANGO_SOURCE_DOC_BOOKS"
    echo "  build:        $ARANGO_BUILD_DOC"
    echo "  build ppdir:  $ARANGO_BUILD_DOC_PRE"
    echo "  build books:  $ARANGO_BUILD_DOC_OUT"
    echo
    echo "versions:"
    echo "  newVersionNumber: $newVersionNumber - from : arangodb/VERSION"
    echo "  VERSION: $VERSION"
    echo "  BROWSEABLE_VERSIONS: $BROWSEABLE_VERSIONS"
    echo "  INSTALLED_GITBOOK_VERSION: $INSTALLED_GITBOOK_VERSION"
    echo "  RELEASE_DIRECTORY: $RELEASE_DIRECTORY"
    echo
    echo "google:"
    echo "  GCHANGE_FREQ: $GCHANGE_FREQ"
    echo "  GPRIORITY: $GPRIORITY"
    echo "  ALL_GSEARCH_ID:"
    for id in  "${ALL_GSEARCH_ID[@]}"; do
        echo "    $id"
    done
    echo

    sleep 2
}

