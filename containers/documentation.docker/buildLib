#!/bin/bash

## this must go

ALLBOOKS="HTTP AQL Manual Cookbook Drivers"
OTHER_MIME="pdf epub mobi"
# shellcheck disable=SC2016
TRIPPLETICS='```'

# shellcheck disable=SC2034

echo "path $(pwd)"
newVersionNumber=$( tr -d '\r\n' < ../../VERSION)

declare -A ALL_GSEARCH_ID
for book in ${ALLBOOKS}; do
    ALL_GSEARCH_ID[$book]=$(  grep "GSEARCH_ID_${book}" ../../VERSIONS |sed 's;.*"\([0-9a-zA-Z:_-]*\)".*;\1;')
done

GCHANGE_FREQ=$(grep "GCHANGE_FREQ" ../../VERSIONS |sed 's;.*"\([0-9a-zA-Z:]*\)".*;\1;')
GPRIORITY=$(grep "GPRIORITY" ../../VERSIONS |sed 's;.*"\([0-9a-zA-Z.]*\)".*;\1;')
BROWSEABLE_VERSIONS=$(grep "BROWSEABLE_VERSIONS" ../../VERSIONS |sed -e 's;" *$;;' -e 's;.*";;')



function ppbook-precheck-bad-code-sections()
{
    NAME="$1"
    echo "##### 1 checking for bad code sections in ${NAME}"
    if grep -qR  "^${TRIPPLETICS} *.* " "${NAME}"; then
        echo ""
        echo "tripple tics with blanks afterwards found: "
        grep -R  "^${TRIPPLETICS} *.* " "${NAME}"
        echo ""
        exit 1
    fi
}

function ppbook-precheck-bad-headings()
{
    NAME="$1"
    echo "##### 2 checking for headers that won't proper display on github in ${NAME}"
    if grep -qRI  '^##*[a-zA-Z]' "${NAME}"; then
        echo ""
        echo "Headlines broken on github found: "
        grep -RI  '^##*[a-zA-Z]' "${NAME}"
        echo ""
        exit 1
    fi
}

function check_summary() {
    #TODO add error checking
    cd "$ARANGO_SOURCE_BOOKS"
    echo "###$(pwd)"
    find "ppbooks/${NAME}" -name \*.md
    find "$2" -name \*.md
    NAME="$1"
    echo "##### 3 checking summary for ${NAME}"
    find "ppbooks/${NAME}" -name \*.md | \
        sed -e "s;ppbooks/${NAME}/;;" | \
        grep -vf SummaryBlacklist.txt | \
        grep -v gitbook-plugin | \
        grep -v node_modules/ | \
        sort > /tmp/is_md.txt

    grep -v '^ *# '< "${NAME}/SUMMARY.md" | \
        grep '(' |sed -e "s;.*(;;" -e "s;).*;;" | \
        sort  > /tmp/is_summary.txt

    if test "$(comm -3 /tmp/is_md.txt /tmp/is_summary.txt|wc -l)" -ne 0; then
        echo ""
        echo "not all files of ${NAME} are mapped to the summary!"
        echo " files found       |    files in summary"
        comm -3 /tmp/is_md.txt /tmp/is_summary.txt
        echo ""
        exit 1
    fi
}

function book-check-leftover-docublocks()
{
    NAME="$1"
    echo "##### 4 checking for left over docublocks in ${NAME}"
    ERRORS=$(grep -rl "startDocuBlock" --include "*.md" "ppbooks/${NAME}" | sed -e "s/^/- /g")
    if test "$(echo -n "${ERRORS}" | wc -l)" -gt 0; then
        echo ""
        echo "startDocuBlock markers still found in generated output files:"
        echo "${ERRORS}"
        echo ""
        exit 1
    fi
}

function book-check-restheader-leftovers()
{
    NAME="$1"
    echo "##### 5 checking for restheader leftovers in ${NAME}"
    ERRORS=$(find "ppbooks/${NAME}" -not \( -path "ppbooks/Drivers/SpringData/*" -prune \) -name "*.md" -exec grep -- '^@[A-Z]*' {} \; -print)
    if test "$(echo -n "${ERRORS}" | wc -l)" -gt 0; then
        echo ""
        echo "found these unconverted Swagger Restapi tags: "
        echo "${ERRORS}"
        echo ""
        exit 1
    fi
}

function ppbook-check-two-links()
{
    NAME="$1"
    echo "##### 6 checking for two links in a single line in ${NAME}"
    ERRORS=$(find "ppbooks/${NAME}" \
                  -path "ppbooks/${NAME}/node_modules" \
                  -prune -o \
                  -name '*.md' \
                  -print | while IFS= read -r ppfile; do
                 ERR=$(grep -e '](.*](' "${ppfile}" | grep -v '|'||true)
                 if test -n "${ERR}"; then
                     printf "\n${ppfile}: \n ${ERR}"
                 fi
             done
          )
    if test "$(printf "${ERRORS}" | wc -l)" -gt 0; then
        echo "";
        echo "found these files with two links in one line: "
        echo "${ERRORS}"
        echo "";
        exit 1;
    fi
}

function ppbook-check-directory-link()
{
    NAME="$1"
    echo "##### 7 checking for invalid md links in ${NAME}"
    ERRORS=$(grep -r -E '\[.*\]\(.*\)' "ppbooks/${NAME}" | \
                    grep '\.md:' | \
                    grep -v html | \
                    grep -v http://| \
                    grep -v https:// | \
                    grep -v header.css | \
                    grep -v node_modules | \
                    grep -v node_modules | \
                    grep -v '\.md')
    nERRORS=$(echo -n "${ERRORS}" | wc -l)
    if test "$nERRORS" -gt 0; then
        echo ""
        echo "Found director links! use ../<directory>/README.md instead!"
        echo "${ERRORS}"
        echo ""
        exit 1
    fi
}

function book-check-images-referenced()
{
    NAME="$1"
    echo "##### 8 checking for unused image files ${NAME}"
    ERRORS=$(find "${NAME}" -name '*.png' | while IFS= read -r image; do
            baseimage=$(basename "$image")
            if ! grep -Rq "${baseimage}" "${NAME}"; then
                printf "\n${image}"
            fi
        done
    )
    if test "$(printf "${ERRORS}" | wc -l)" -gt 0; then
        echo "";
        echo "the following images are not referenced by any page: "
        echo "${ERRORS}"
        echo "";
        exit 1;
    fi
}

# checks we do not reach yet

function ppbook-check-html-link()
{
    set -o pipefail
    NAME="$1"
    MSG="$2"
    echo "##### zzz checking for invalid HTML links in ${NAME}"
    echo "${ALLBOOKS}" | tr " " "\n" | sed -e 's;^;/;' -e 's;$;/;' > /tmp/books.regex

    grep -r -E '\[.*\]\(.*\)' "ppbooks/${NAME}"| \
        grep '\.md:'| grep 'html'| \
        grep -v 'http://' | \
        grep -v 'https://' | \
        grep -v 'header.css' | \
        grep -v -f /tmp/books.regex > /tmp/relative_html_links.txt

    if test "$(wc -l < /tmp/relative_html_links.txt)" -gt 0; then
        echo ""
        echo "Found links to .html files inside of the document! use <foo>.md instead!"
        echo "${MSG}"
        cat  /tmp/relative_html_links.txt
        echo ""
        exit 1
    fi
}

book_check_post_build_markdown_leftovers() {
    local name="$1"
    local book_out="$2"
    echo "##### checking for remaining markdown snippets in the HTML output of ${name} in $book_out"

    ERRORS=$(find "$book_out" -name '*.html' -exec grep -- '^##' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found these unconverted markdown titles"
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep -- '&amp;gt;' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found these double converted > signs"
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '"[a-zA-Z/\.]*\.md\"[ />]' {} \; -print | grep -v data-filepath)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found dangling markdown links; see the list above "
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '"[a-zA-Z/\.]*\.md#' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found dangling markdown links: "
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep "${TRIPPLETICS}" {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found dangling markdown code sections: "
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '\]<a href' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found unconverted markdown links: "
    fi

    ERRORS=$(find "$book_out" -name '*.html' -exec grep '\[.*\](.*[\.html|\.md|http|#.*])' {} \; -print)
    if [[ -n "${ERRORS}" ]]; then
        echo "${ERRORS}"
        ferr "found unconverted markdown links: "
    fi
}


function check-dangling-anchors()
{
    rm -rf /tmp/tags/
    echo "##### checking for dangling anchors"
    find books/ -name '*.html' | while IFS= read -r htmlf; do
        fn=$(basename "${htmlf}")
        dir=$(sed "s;/$fn;;" <<< "$htmlf")
        mkdir -p "/tmp/tags/${dir}"
        grep '<h. ' < "${htmlf}" | \
            sed -e 's;.*id=";;' -e 's;".*;;' > "/tmp/tags/${dir}/${fn}"
    done

    fail=0
    rm -f /tmp/failduplicatetags.txt
    find /tmp/tags -type f | while IFS= read -r htmlf; do
        sort "${htmlf}" |grep -v ^$ > /tmp/sorted.txt
        sort -u "${htmlf}" |grep -v ^$ > /tmp/sortedunique.txt
        if test "$(comm -3 /tmp/sorted.txt /tmp/sortedunique.txt|wc -l)" -ne 0; then
            echo "in ${htmlf}: "
            comm -3 /tmp/sorted.txt /tmp/sortedunique.txt
            touch /tmp/failduplicatetags.txt
        fi
    done

    rm -f /tmp/sorted.txt /tmp/sortedunique.txt
    if test -f /tmp/failduplicatetags.txt; then
        echo "duplicate anchors detected - see above"
        rm -f /tmp/failduplicatetags.txt
        exit 1
    fi

    rm -f /tmp/anchorlist.txt

    echo "##### fetching anchors from generated http files"
    for file in $(find books -name \*.html); do
        # - strip of the menu
        # - then the page tail.
        # - remove links to external pages
        cat $file | \
            sed -r -n -e '/normal markdown-section/,${p}'| \
            sed -r -n -e '/.*id="page-footer".*/q;p' | \
            grep '<a href="' | \
            grep -v 'target="_blank"' | \
            sed -e 's;.*href=";;' -e 's;".*;;' > /tmp/thisdoc.txt
        # Links with anchors:
        cat /tmp/thisdoc.txt |grep '#' | sed "s;\(.*\)#\(.*\);${file},\1,\2;" >> /tmp/anchorlist.txt
        # links without anchors:
        cat /tmp/thisdoc.txt |grep -v '#' | sed "s;\(.*\);${file},\1,;" >> /tmp/anchorlist.txt

    done

    echo "##### cross checking anchors"
    NO=0
    echo "${NO}" > /tmp/anchorlistcount.txt
    # shellcheck disable=SC2002
    cat /tmp/anchorlist.txt | while IFS= read -r i; do
        ANCHOR=$(echo "$i" | cut '-d,' -f 3)
        FN=$(echo "$i" | cut '-d,' -f 2)
        SFN=$(echo "$i" | cut '-d,' -f 1)

        if test -z "$FN"; then
            FN="$SFN"
        else
            SFNP=$(sed 's;/[a-zA-Z0-9.-]*.html;;' <<< "$SFN")
            FN="${SFNP}/${FN}"
        fi
        if test -d "$FN"; then
            FN="${FN}index.html"
        fi
        if test ! -f "/tmp/tags/${FN}"; then
            echo ""
            echo "File referenced by ${i} doesn't exist."
            NO=$((NO + 1))
            echo ""
        else
            if test -n "$ANCHOR"; then
                if grep -q "^$ANCHOR$" "/tmp/tags/${FN}"; then
                    true
                else
                    echo ""
                    echo "Anchor not found in $i"
                    NO=$((NO + 1))
                    echo "available anchors in that file:"
                    cat "/tmp/tags/${FN}" |sort
                    echo ""
                fi
            fi
        fi
        echo "${NO}" > /tmp/anchorlistcount.txt
    done
    NO="$(cat /tmp/anchorlistcount.txt)"
    if test "${NO}" -gt 0; then
        echo ""
        echo "${NO} Dangling anchors found!"
        echo ""
        echo "${1}"
        echo ""
        exit 1
    fi
    rm -rf /tmp/anchorlist.txt /tmp/tags
}

#************************************************************
# Check docublocks - checks whether docublock are
#  - files in intermediate output directories and temporary
#    files are excludes (with # in their names)
#  - unique in the source
#  - all docublocks are used somewhere in the documentation
#
function check-docublocks()
{
    grep -R '@startDocuBlock' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v '@startDocuBlockInline' |\
        grep -v stash |\
        grep -v ppbook |\
        grep -v allComments.txt |\
        grep -v Makefile |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             > /tmp/rawindoc.txt

    grep -R '@startDocuBlockInline' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v ppbook |\
        grep -v stash |\
        grep -v allComments.txt |\
        grep -v Makefile |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             >> /tmp/rawindoc.txt

    sed  -e "s;\r$;;" -e "s;.*ck ;;" -e "s;.*ne ;;" < /tmp/rawindoc.txt |sort -u > /tmp/indoc.txt

    grep -R '^@startDocuBlock' ../DocuBlocks --include "*.md" |grep -v aardvark > /tmp/rawinprog.txt
    # searching the Inline docublocks needs some more blacklisting:
    grep -R '@startDocuBlockInline' --include "*.h" --include "*.cpp" --include "*.js" --include "*.md" . |\
        grep -v ppbook |\
        grep -v stash |\
        grep -v allComments.txt |\
        grep -v build.sh |\
        grep -v '.*~:.*' |\
        grep -v '.*#.*:.*' \
             >> /tmp/rawinprog.txt

    # These files are converted to docublocks on the fly and only live in memory.
    for file in ../Examples/*.json ; do
        echo "$file" |sed -e "s;.*/;Generated: @startDocuBlock program_options_;" -e "s;.json;;" >> /tmp/rawinprog.txt
    done
    echo "Generated: startDocuBlockInline errorCodes">> /tmp/rawinprog.txt

    sed -e "s;\r$;;" -e "s;.*ck ;;" -e "s;.*ne ;;" < /tmp/rawinprog.txt  |sort > /tmp/inprog_raw.txt
    sort -u < /tmp/inprog_raw.txt > /tmp/inprog.txt

    if test "$(wc -l < /tmp/inprog.txt)" -ne "$(wc -l < /tmp/inprog_raw.txt)"; then
        echo ""
        echo "Duplicate entry found in the source trees:"
        comm -3 /tmp/inprog_raw.txt /tmp/inprog.txt
        echo ""
        echo "${1}"
        echo ""
        exit 1
    fi

    if test "$(comm -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -ne 0; then
        echo ""
        echo "Not all blocks were found on both sides:"
        echo "Documentation      |     Programcode:"
        comm -3 /tmp/indoc.txt /tmp/inprog.txt
        if test "$(comm -2 -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -gt 0; then
            echo "Documentation: "
            for grepit in $(comm -2 -3 /tmp/indoc.txt /tmp/inprog.txt); do
                grep "$grepit" /tmp/rawindoc.txt
            done
        fi
        if test "$(comm -1 -3 /tmp/indoc.txt /tmp/inprog.txt |wc -l)" -gt 0; then
            echo "Program code:"
            for grepit in $(comm -1 -3 /tmp/indoc.txt /tmp/inprog.txt); do
                grep "$grepit" /tmp/rawinprog.txt | sed "s;/// @startDocuBlock;\t\t;"
            done
        fi
        echo ""
        echo "${1}"
        echo ""
        exit 1
    fi
}
#### Snippets to be replaced

## build non html books
## function build-book-dist()
## {
##     NAME="$1"
##     export DISPLAY="$2"
##     cd "ppbooks/${NAME}"
##     for ext in ${OTHER_MIME}; do
##         OUTPUT="${OUTPUT_DIR}/ArangoDB_${NAME}_${newVersionNumber}.${ext}"
##         if gitbook "${GITBOOK_ARGS[@]}" "${ext}" ./ "${OUTPUT}"; then
##             echo "success building ${OUTPUT}"
##         else
##             exit 1
##         fi
##     done
## }

#### GOOD FUNCTIONS


# not required anymore
build_book_symlinks(){
    local build_out="$1"

    section "generate backwards compatibility symlinks for ${NAME}"
    cd "$build_out" || ferr "could not change into out dir: $build_out"

    # find all README, then cd into the dir containing the file and create a symlink
    find -iname README.md -exedir ln -s index.html README.html +

    ## # probably - find md files and create a symlink from index.html to readme.html
    ## pwd
    ## find . -name "README.md" |\
    ##     sed -e 's:README\.md$::' |\
    ##     awk '{print "ln -s index.html " "$1" "README.html"}' |\
    ##     bash
}

#start_X11_display() {
#    local pidfile="$1"
#
#    if test -f "${pidfile}"; then
#        stop_X11_display "${pidfile}"
#    fi
#    #start xvfb
#    /usr/bin/daemon "--pidfile=${pidfile}" --name=xvfb --inherit --output=/tmp/xvfb.log --  Xvfb "${DISPLAY}" -screen 0 800x600x16  -ac -pn -noreset
#}
#
#stop_X11_display() {
#    local pidfile=$1
#    kill "$(cat "${pidfile}")"
#    rm -f "${pidfile}"
#}

